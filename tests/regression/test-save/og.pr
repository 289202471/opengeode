SYSTEM og;
    /* CIF TEXT (159, 221), (289, 188) */
    -- Text area for declarations and comments

use dv comment 'dataview.asn';

signal run;
signal saved_signal(BoolType);
signal we;
    /* CIF ENDTEXT */
    CHANNEL c
        FROM ENV TO og WITH run,
saved_signal;
        FROM og TO ENV WITH we;
    ENDCHANNEL;
    BLOCK og;
        SIGNALROUTE r
            FROM ENV TO og WITH run,
saved_signal;
            FROM og TO ENV WITH we;
        CONNECT c AND r;
        /* CIF PROCESS (225, 50), (150, 75) */
        PROCESS og;
            /* CIF TEXT (335, 58), (396, 136) */
            --  Demonstrate how to simulate the behaviour of the SAVE
-- signal. The actual SAVE implies dynamic memory allocation.
-- But using a controlled-size array and a continuous signal it
-- is easy to reproduce the same behaviour.

dcl save_buffer SeqOf;

dcl param BoolType;
            /* CIF ENDTEXT */
            /* CIF START (0, 226), (70, 35) */
            START;
                /* CIF NEXTSTATE (0, 276), (70, 35) */
                NEXTSTATE wait;
            /* CIF STATE (291, 227), (70, 35) */
            STATE wait;
                /* CIF INPUT (91, 282), (84, 35) */
                INPUT run;
                    /* CIF NEXTSTATE (79, 332), (107, 35) */
                    NEXTSTATE Running;
                /* CIF INPUT (296, 282), (162, 35) */
                INPUT saved_signal(param);
                    /* CIF DECISION (296, 332), (161, 50) */
                    DECISION length(save_buffer);
                            /* CIF ANSWER (253, 402), (60, 34) */
                            (<10):
                                /* CIF TASK (195, 451), (174, 40) */
                                TASK save_buffer :=
save_buffer // {param};
                            /* CIF ANSWER (457, 402), (53, 34) */
                            (10):
                                /* CIF PROCEDURECALL (382, 451), (202, 38) */
                                CALL writeln('Buffer Overflow!');
                    ENDDECISION;
                    /* CIF NEXTSTATE (342, 506), (70, 35) */
                    NEXTSTATE wait;
            ENDSTATE;
            /* CIF STATE (929, 221), (88, 35) */
            STATE Running;
                /* CIF INPUT (1053, 276), (70, 35) */
                INPUT Run;
                    /* CIF PROCEDURECALL (990, 326), (194, 35) */
                    CALL writeln('Already running');
                    /* CIF NEXTSTATE (1053, 376), (70, 35) */
                    NEXTSTATE -;
                /* CIF PROVIDED (718, 276), (181, 35) */
                PROVIDED length(save_buffer) > 0;
                    /* CIF TASK (717, 326), (182, 35) */
                    TASK param := save_buffer(0);
                    /* CIF TASK (636, 376), (344, 35) */
                    TASK save_buffer := save_buffer(1, length(save_buffer));
                    /* CIF TASK (647, 426), (323, 56) */
                    TASK save_buffer := if length(save_buffer) > 1
then {true} else save_buffer // {false } fi;
                    /* CIF TASK (650, 497), (316, 56) */
                    TASK save_buffer := if length(save_buffer) > 1
then save_buffer(1, length(save_buffer))
else {} fi;
                    /* CIF PROCEDURECALL (708, 568), (200, 35) */
                    CALL writeln('Running: ', param);
                    /* CIF NEXTSTATE (764, 618), (88, 35) */
                    NEXTSTATE Running;
            ENDSTATE;
        ENDPROCESS og;
    ENDBLOCK;
ENDSYSTEM;