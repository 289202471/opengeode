#ifndef GENERATED_ASN1SCC_DATAVIEW_UNIQ_H
#define GENERATED_ASN1SCC_DATAVIEW_UNIQ_H
/*
Code automatically generated by asn1scc tool
*/
#include "asn1crt.h"

#ifdef  __cplusplus
extern "C" {
#endif



typedef asn1SccUint T_UInt32;

#define T_UInt32_REQUIRED_BYTES_FOR_ENCODING       4 
#define T_UInt32_REQUIRED_BITS_FOR_ENCODING        32
#define T_UInt32_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define T_UInt32_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define T_UInt32_REQUIRED_BYTES_FOR_XER_ENCODING   41

void T_UInt32_Initialize(T_UInt32* pVal);
flag T_UInt32_IsConstraintValid(const T_UInt32* val, int* pErrCode);
flag T_UInt32_Equal(const T_UInt32* val1, const T_UInt32* val2);

#ifndef ERR_T_UInt32 
#define ERR_T_UInt32		1001  /*(0 .. 4294967295)*/
#endif

typedef asn1SccUint TASTE_Peek_id;

#define TASTE_Peek_id_REQUIRED_BYTES_FOR_ENCODING       4 
#define TASTE_Peek_id_REQUIRED_BITS_FOR_ENCODING        32
#define TASTE_Peek_id_REQUIRED_BYTES_FOR_ACN_ENCODING   4 
#define TASTE_Peek_id_REQUIRED_BITS_FOR_ACN_ENCODING    32
#define TASTE_Peek_id_REQUIRED_BYTES_FOR_XER_ENCODING   51

void TASTE_Peek_id_Initialize(TASTE_Peek_id* pVal);
flag TASTE_Peek_id_IsConstraintValid(const TASTE_Peek_id* val, int* pErrCode);
flag TASTE_Peek_id_Equal(const TASTE_Peek_id* val1, const TASTE_Peek_id* val2);

#ifndef ERR_TASTE_Peek_id 
#define ERR_TASTE_Peek_id		1002  /*(0 .. 4294967295)*/
#endif

typedef struct {    int nCount; 
    
    TASTE_Peek_id arr[10];
} TASTE_Peek_id_list;

#define TASTE_Peek_id_list_REQUIRED_BYTES_FOR_ENCODING       41 
#define TASTE_Peek_id_list_REQUIRED_BITS_FOR_ENCODING        324
#define TASTE_Peek_id_list_REQUIRED_BYTES_FOR_ACN_ENCODING   41 
#define TASTE_Peek_id_list_REQUIRED_BITS_FOR_ACN_ENCODING    324
#define TASTE_Peek_id_list_REQUIRED_BYTES_FOR_XER_ENCODING   551

void TASTE_Peek_id_list_Initialize(TASTE_Peek_id_list* pVal);
flag TASTE_Peek_id_list_IsConstraintValid(const TASTE_Peek_id_list* val, int* pErrCode);
flag TASTE_Peek_id_list_Equal(const TASTE_Peek_id_list* val1, const TASTE_Peek_id_list* val2);

#ifndef ERR_TASTE_Peek_id_list 
#define ERR_TASTE_Peek_id_list		1003  /*(SIZE(1 .. 10))*/
#endif

typedef struct {    
    TASTE_Peek_id arr[3];
} FixedIntList;

#define FixedIntList_REQUIRED_BYTES_FOR_ENCODING       12 
#define FixedIntList_REQUIRED_BITS_FOR_ENCODING        96
#define FixedIntList_REQUIRED_BYTES_FOR_ACN_ENCODING   12 
#define FixedIntList_REQUIRED_BITS_FOR_ACN_ENCODING    96
#define FixedIntList_REQUIRED_BYTES_FOR_XER_ENCODING   182

void FixedIntList_Initialize(FixedIntList* pVal);
flag FixedIntList_IsConstraintValid(const FixedIntList* val, int* pErrCode);
flag FixedIntList_Equal(const FixedIntList* val1, const FixedIntList* val2);

#ifndef ERR_FixedIntList 
#define ERR_FixedIntList		1004  /*(SIZE(3))*/
#endif

typedef enum {
    one = 0,
    two = 1,
    three = 2,
    four = 3,
    five = 4
} MyEnum;

#define MyEnum_REQUIRED_BYTES_FOR_ENCODING       1 
#define MyEnum_REQUIRED_BITS_FOR_ENCODING        3
#define MyEnum_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MyEnum_REQUIRED_BITS_FOR_ACN_ENCODING    3
#define MyEnum_REQUIRED_BYTES_FOR_XER_ENCODING   26

void MyEnum_Initialize(MyEnum* pVal);
flag MyEnum_IsConstraintValid(const MyEnum* val, int* pErrCode);
flag MyEnum_Equal(const MyEnum* val1, const MyEnum* val2);

#ifndef ERR_MyEnum_unknown_enumeration_value 
#define ERR_MyEnum_unknown_enumeration_value		1006  /**/
#endif
#ifndef ERR_MyEnum 
#define ERR_MyEnum		1005  /**/
#endif

typedef asn1SccUint MySimpleSeq_a;

#define MySimpleSeq_a_REQUIRED_BYTES_FOR_ENCODING       1 
#define MySimpleSeq_a_REQUIRED_BITS_FOR_ENCODING        8
#define MySimpleSeq_a_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MySimpleSeq_a_REQUIRED_BITS_FOR_ACN_ENCODING    8
#define MySimpleSeq_a_REQUIRED_BYTES_FOR_XER_ENCODING   51

void MySimpleSeq_a_Initialize(MySimpleSeq_a* pVal);
flag MySimpleSeq_a_IsConstraintValid(const MySimpleSeq_a* val, int* pErrCode);
flag MySimpleSeq_a_Equal(const MySimpleSeq_a* val1, const MySimpleSeq_a* val2);

#ifndef ERR_MySimpleSeq_a 
#define ERR_MySimpleSeq_a		1007  /*(0 .. 255)*/
#endif

typedef struct {
    MySimpleSeq_a a;
    flag b;
    MyEnum c;
} MySimpleSeq;

#define MySimpleSeq_REQUIRED_BYTES_FOR_ENCODING       2 
#define MySimpleSeq_REQUIRED_BITS_FOR_ENCODING        12
#define MySimpleSeq_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define MySimpleSeq_REQUIRED_BITS_FOR_ACN_ENCODING    12
#define MySimpleSeq_REQUIRED_BYTES_FOR_XER_ENCODING   90

void MySimpleSeq_Initialize(MySimpleSeq* pVal);
flag MySimpleSeq_IsConstraintValid(const MySimpleSeq* val, int* pErrCode);
flag MySimpleSeq_Equal(const MySimpleSeq* val1, const MySimpleSeq* val2);



typedef asn1SccUint MySeqOf_elm;

#define MySeqOf_elm_REQUIRED_BYTES_FOR_ENCODING       1 
#define MySeqOf_elm_REQUIRED_BITS_FOR_ENCODING        4
#define MySeqOf_elm_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MySeqOf_elm_REQUIRED_BITS_FOR_ACN_ENCODING    4
#define MySeqOf_elm_REQUIRED_BYTES_FOR_XER_ENCODING   47

void MySeqOf_elm_Initialize(MySeqOf_elm* pVal);
flag MySeqOf_elm_IsConstraintValid(const MySeqOf_elm* val, int* pErrCode);
flag MySeqOf_elm_Equal(const MySeqOf_elm* val1, const MySeqOf_elm* val2);

#ifndef ERR_MySeqOf_elm 
#define ERR_MySeqOf_elm		1008  /*(0 .. 10)*/
#endif

typedef struct {    int nCount; 
    
    MySeqOf_elm arr[3];
} MySeqOf;

#define MySeqOf_REQUIRED_BYTES_FOR_ENCODING       2 
#define MySeqOf_REQUIRED_BITS_FOR_ENCODING        14
#define MySeqOf_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define MySeqOf_REQUIRED_BITS_FOR_ACN_ENCODING    14
#define MySeqOf_REQUIRED_BYTES_FOR_XER_ENCODING   136

void MySeqOf_Initialize(MySeqOf* pVal);
flag MySeqOf_IsConstraintValid(const MySeqOf* val, int* pErrCode);
flag MySeqOf_Equal(const MySeqOf* val1, const MySeqOf* val2);

#ifndef ERR_MySeqOf 
#define ERR_MySeqOf		1009  /*(SIZE(1 .. 3))*/
#endif

typedef asn1SccUint MySetOf_elm;

#define MySetOf_elm_REQUIRED_BYTES_FOR_ENCODING       1 
#define MySetOf_elm_REQUIRED_BITS_FOR_ENCODING        4
#define MySetOf_elm_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MySetOf_elm_REQUIRED_BITS_FOR_ACN_ENCODING    4
#define MySetOf_elm_REQUIRED_BYTES_FOR_XER_ENCODING   47

void MySetOf_elm_Initialize(MySetOf_elm* pVal);
flag MySetOf_elm_IsConstraintValid(const MySetOf_elm* val, int* pErrCode);
flag MySetOf_elm_Equal(const MySetOf_elm* val1, const MySetOf_elm* val2);

#ifndef ERR_MySetOf_elm 
#define ERR_MySetOf_elm		1010  /*(0 .. 10)*/
#endif

typedef struct {    int nCount; 
    
    MySetOf_elm arr[3];
} MySetOf;

#define MySetOf_REQUIRED_BYTES_FOR_ENCODING       2 
#define MySetOf_REQUIRED_BITS_FOR_ENCODING        14
#define MySetOf_REQUIRED_BYTES_FOR_ACN_ENCODING   2 
#define MySetOf_REQUIRED_BITS_FOR_ACN_ENCODING    14
#define MySetOf_REQUIRED_BYTES_FOR_XER_ENCODING   136

void MySetOf_Initialize(MySetOf* pVal);
flag MySetOf_IsConstraintValid(const MySetOf* val, int* pErrCode);
flag MySetOf_Equal(const MySetOf* val1, const MySetOf* val2);

#ifndef ERR_MySetOf 
#define ERR_MySetOf		1011  /*(SIZE(1 .. 3))*/
#endif

typedef enum {
    aa = 0,
    bb = 1
} MyChoice_b;

#define MyChoice_b_REQUIRED_BYTES_FOR_ENCODING       1 
#define MyChoice_b_REQUIRED_BITS_FOR_ENCODING        1
#define MyChoice_b_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MyChoice_b_REQUIRED_BITS_FOR_ACN_ENCODING    1
#define MyChoice_b_REQUIRED_BYTES_FOR_XER_ENCODING   32

void MyChoice_b_Initialize(MyChoice_b* pVal);
flag MyChoice_b_IsConstraintValid(const MyChoice_b* val, int* pErrCode);
flag MyChoice_b_Equal(const MyChoice_b* val1, const MyChoice_b* val2);

#ifndef ERR_MyChoice_b_unknown_enumeration_value 
#define ERR_MyChoice_b_unknown_enumeration_value		1013  /**/
#endif
#ifndef ERR_MyChoice_b 
#define ERR_MyChoice_b		1012  /**/
#endif

typedef struct {
    enum {
        MyChoice_NONE,
        a_PRESENT,
        b_PRESENT 
    } kind;
    union {
        flag a;
        MyChoice_b b;
    } u; 
} MyChoice;

#define MyChoice_REQUIRED_BYTES_FOR_ENCODING       1 
#define MyChoice_REQUIRED_BITS_FOR_ENCODING        3
#define MyChoice_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MyChoice_REQUIRED_BITS_FOR_ACN_ENCODING    3
#define MyChoice_REQUIRED_BYTES_FOR_XER_ENCODING   41

void MyChoice_Initialize(MyChoice* pVal);
flag MyChoice_IsConstraintValid(const MyChoice* val, int* pErrCode);
flag MyChoice_Equal(const MyChoice* val1, const MyChoice* val2);

#ifndef ERR_MyChoice_unknown_choice_index 
#define ERR_MyChoice_unknown_choice_index		1014  /**/
#endif

typedef struct {
    flag a;
    MyChoice b;
} MySeq;

#define MySeq_REQUIRED_BYTES_FOR_ENCODING       1 
#define MySeq_REQUIRED_BITS_FOR_ENCODING        4
#define MySeq_REQUIRED_BYTES_FOR_ACN_ENCODING   1 
#define MySeq_REQUIRED_BITS_FOR_ACN_ENCODING    4
#define MySeq_REQUIRED_BYTES_FOR_XER_ENCODING   62

void MySeq_Initialize(MySeq* pVal);
flag MySeq_IsConstraintValid(const MySeq* val, int* pErrCode);
flag MySeq_Equal(const MySeq* val1, const MySeq* val2);



 

/* ================= Encoding/Decoding function prototypes =================
 * These functions are placed at the end of the file to make sure all types
 * have been declared first, in case of parameterized ACN encodings
 * ========================================================================= */

flag T_UInt32_Encode(const T_UInt32* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_UInt32_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode);
flag T_UInt32_ACN_Encode(const T_UInt32* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag T_UInt32_ACN_Decode(T_UInt32* pVal, BitStream* pBitStrm, int* pErrCode);
flag TASTE_Peek_id_Encode(const TASTE_Peek_id* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag TASTE_Peek_id_Decode(TASTE_Peek_id* pVal, BitStream* pBitStrm, int* pErrCode);
flag TASTE_Peek_id_ACN_Encode(const TASTE_Peek_id* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag TASTE_Peek_id_ACN_Decode(TASTE_Peek_id* pVal, BitStream* pBitStrm, int* pErrCode);
flag TASTE_Peek_id_list_Encode(const TASTE_Peek_id_list* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag TASTE_Peek_id_list_Decode(TASTE_Peek_id_list* pVal, BitStream* pBitStrm, int* pErrCode);
flag TASTE_Peek_id_list_ACN_Encode(const TASTE_Peek_id_list* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag TASTE_Peek_id_list_ACN_Decode(TASTE_Peek_id_list* pVal, BitStream* pBitStrm, int* pErrCode);
flag FixedIntList_Encode(const FixedIntList* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag FixedIntList_Decode(FixedIntList* pVal, BitStream* pBitStrm, int* pErrCode);
flag FixedIntList_ACN_Encode(const FixedIntList* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag FixedIntList_ACN_Decode(FixedIntList* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyEnum_Encode(const MyEnum* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyEnum_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyEnum_ACN_Encode(const MyEnum* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyEnum_ACN_Decode(MyEnum* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySimpleSeq_a_Encode(const MySimpleSeq_a* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySimpleSeq_a_Decode(MySimpleSeq_a* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySimpleSeq_a_ACN_Encode(const MySimpleSeq_a* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySimpleSeq_a_ACN_Decode(MySimpleSeq_a* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySimpleSeq_Encode(const MySimpleSeq* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySimpleSeq_Decode(MySimpleSeq* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySimpleSeq_ACN_Encode(const MySimpleSeq* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySimpleSeq_ACN_Decode(MySimpleSeq* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeqOf_elm_Encode(const MySeqOf_elm* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeqOf_elm_Decode(MySeqOf_elm* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeqOf_elm_ACN_Encode(const MySeqOf_elm* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeqOf_elm_ACN_Decode(MySeqOf_elm* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeqOf_Encode(const MySeqOf* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeqOf_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeqOf_ACN_Encode(const MySeqOf* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeqOf_ACN_Decode(MySeqOf* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySetOf_elm_Encode(const MySetOf_elm* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySetOf_elm_Decode(MySetOf_elm* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySetOf_elm_ACN_Encode(const MySetOf_elm* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySetOf_elm_ACN_Decode(MySetOf_elm* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySetOf_Encode(const MySetOf* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySetOf_Decode(MySetOf* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySetOf_ACN_Encode(const MySetOf* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySetOf_ACN_Decode(MySetOf* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyChoice_b_Encode(const MyChoice_b* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyChoice_b_Decode(MyChoice_b* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyChoice_b_ACN_Encode(const MyChoice_b* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyChoice_b_ACN_Decode(MyChoice_b* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyChoice_Encode(const MyChoice* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyChoice_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode);
flag MyChoice_ACN_Encode(const MyChoice* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MyChoice_ACN_Decode(MyChoice* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeq_Encode(const MySeq* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeq_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode);
flag MySeq_ACN_Encode(const MySeq* val, BitStream* pBitStrm, int* pErrCode, flag bCheckConstraints);
flag MySeq_ACN_Decode(MySeq* pVal, BitStream* pBitStrm, int* pErrCode); 


#ifdef  __cplusplus
}
#define ENUM_one	one
#define ENUM_two	two
#define ENUM_three	three
#define ENUM_four	four
#define ENUM_five	five
#define ENUM_aa	aa
#define ENUM_bb	bb
#define CHOICE_a_PRESENT	MyChoice::a_PRESENT
#define CHOICE_b_PRESENT	MyChoice::b_PRESENT

#endif

#endif
