/*
Code automatically generated by asn1scc tool
*/
#include <limits.h>
#include <string.h>
#include <math.h>
#include "dataview-uniq.h"

#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMyInteger_Initialize(asn1SccMyInteger* pVal)
{
    *pVal = (asn1SccMyInteger) 0;
}
#endif

 
flag asn1SccMyInteger_IsConstraintValid(const asn1SccMyInteger* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 255);
	*pErrCode = ret ? 0 : ERR_asn1SccMyInteger;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSome_Thing_Initialize(asn1SccSome_Thing* pVal)
{
    *pVal = (asn1SccSome_Thing) 0;
}
#endif

 
flag asn1SccSome_Thing_IsConstraintValid(const asn1SccSome_Thing* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccMyInteger_IsConstraintValid(pVal, pErrCode);

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSeqOf_Initialize(asn1SccSeqOf* pVal)
{
    *pVal = (asn1SccSeqOf) {    .nCount = 0,    .arr = 
    {
        
    }
};
}
#endif

 
flag asn1SccSeqOf_IsConstraintValid(const asn1SccSeqOf* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= 100);
	*pErrCode = ret ? 0 : ERR_asn1SccSeqOf;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = asn1SccMyInteger_IsConstraintValid(&pVal->arr[i1], pErrCode);
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMy_OctStr_Initialize(asn1SccMy_OctStr* pVal)
{
    *pVal = (asn1SccMy_OctStr) {0,
    {
    }
};
}
#endif

 
flag asn1SccMy_OctStr_IsConstraintValid(const asn1SccMy_OctStr* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= pVal->nCount && pVal->nCount <= 20);
	*pErrCode = ret ? 0 : ERR_asn1SccMy_OctStr;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccType1_Initialize(asn1SccType1* pVal)
{
    *pVal = (asn1SccType1) 0;
}
#endif

 
flag asn1SccType1_IsConstraintValid(const asn1SccType1* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = (0 <= *pVal && *pVal <= 1);
	*pErrCode = ret ? 0 : ERR_asn1SccType1;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccType2_Initialize(asn1SccType2* pVal)
{
    *pVal = (asn1SccType2) FALSE;
}
#endif

 
flag asn1SccType2_IsConstraintValid(const asn1SccType2* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = TRUE; *pErrCode = 0;

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccToto_Initialize(asn1SccToto* pVal)
{
    *pVal = (asn1SccToto) {
    .elem_1 = 0,
    .elem_2 = FALSE
};
}
#endif

 
flag asn1SccToto_IsConstraintValid(const asn1SccToto* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	ret = asn1SccType1_IsConstraintValid(&pVal->elem_1, pErrCode);
	if (ret) {
	    ret = asn1SccType2_IsConstraintValid(&pVal->elem_2, pErrCode);
	
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccSeqBool_Initialize(asn1SccSeqBool* pVal)
{
    *pVal = (asn1SccSeqBool) {    .nCount = 1,    .arr = 
    {
        FALSE        
    }
};
}
#endif

 
flag asn1SccSeqBool_IsConstraintValid(const asn1SccSeqBool* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	int i1=0;
	*pErrCode=0;

	(void)pVal;

	ret = (1 <= pVal->nCount && pVal->nCount <= 5);
	*pErrCode = ret ? 0 : ERR_asn1SccSeqBool;
	i1 = 0;
	while (ret && (i1< pVal->nCount)) {
	    ret = TRUE; *pErrCode = 0;
	    i1 = i1+1;
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMyChoice_a_b_Initialize(asn1SccMyChoice_a_b* pVal)
{
    *pVal = (asn1SccMyChoice_a_b) {
    .kind = c_PRESENT,
    .u = { .c = FALSE}
};
}
#endif

 
flag asn1SccMyChoice_a_b_IsConstraintValid(const asn1SccMyChoice_a_b* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case c_PRESENT :
	        ret = TRUE; *pErrCode = 0;
	        break;
	    case d_PRESENT :
	        ret = TRUE; *pErrCode = 0;
	        break;
	    default:
		    *pErrCode = 805306369;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMyChoice_a_Initialize(asn1SccMyChoice_a* pVal)
{
    *pVal = (asn1SccMyChoice_a) {
    .kind = b_PRESENT,
    .u = { .b = {
    .kind = c_PRESENT,
    .u = { .c = FALSE}
}}
};
}
#endif

 
flag asn1SccMyChoice_a_IsConstraintValid(const asn1SccMyChoice_a* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case b_PRESENT :
	        ret = asn1SccMyChoice_a_b_IsConstraintValid(&pVal->u.b, pErrCode);
	        break;
	    case e_PRESENT :
	        ret = TRUE; *pErrCode = 0;
	        break;
	    default:
		    *pErrCode = 805306370;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}
#if !defined(_MSC_VER) || _MSC_VER >= 1800
void asn1SccMyChoice_Initialize(asn1SccMyChoice* pVal)
{
    *pVal = (asn1SccMyChoice) {
    .kind = a_PRESENT,
    .u = { .a = {
    .kind = b_PRESENT,
    .u = { .b = {
    .kind = c_PRESENT,
    .u = { .c = FALSE}
}}
}}
};
}
#endif

 
flag asn1SccMyChoice_IsConstraintValid(const asn1SccMyChoice* pVal, int* pErrCode)
{
    
    flag ret = TRUE;
	*pErrCode=0;

	(void)pVal;

	switch (pVal->kind) {
	    case a_PRESENT :
	        ret = asn1SccMyChoice_a_IsConstraintValid(&pVal->u.a, pErrCode);
	        break;
	    case f_PRESENT :
	        ret = TRUE; *pErrCode = 0;
	        break;
	    default:
		    *pErrCode = 805306371;   //COVERAGE_IGNORE
		    ret = FALSE;                    //COVERAGE_IGNORE
	}

	return ret;
}

const asn1SccSeqOf default_seqof = {    .nCount = 3,    .arr = 
    {
        4,
        7,
        9        
    }
};

const asn1SccMy_OctStr default_str = {4,
    {
        0xDE,
        0xAD,
        0xBE,
        0xEF
    }
};

const asn1SccMy_OctStr test_string = {5,
    {
        0x68,
        0x65,
        0x6C,
        0x6C,
        0x6F
    }
};
