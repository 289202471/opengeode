group adb;

/* top-level: template for the code of a process
 * name: process name
 * dcl: list of local declarations
 * pdecl : inner procedure declarations (array)
 * pcode : inner procedure code (array)
 * vars: list of local variables and sort: { name: str, sort: str })
 * arrs_inp : code handling the reception of messages (array of <input_signal>)
 * arrs_async_ri : code for the required interfaces
 * constants: list of start named start transitions (when using substates)
 * states: list of states
 * asn1_mod : list of ASN.1 modules
 * simu, dll : flags set by the user for generation of optional code
*/
process(name, decl, pdecl, pcode vars, arrs_inp, arrs_async_ri, constants, states, asn1_mod, simu, dll) ::= <<
--  This file was generated automatically: DO NOT MODIFY !

<if(asn1_mod)>
--  ASN.1 Modules used by this process, and generated by ASN1SCC
<asn1_mod: {each |
with <each>;
use <each>;}; separator="\n">

-- ASN.1 Runtime, containing basic types
with AdaASN1rtl;
use AdaASN1rtl;
<endif>


--  Include Ada generic libraries used by the generated code
with System.IO;
use System.IO;

with Ada.Unchecked_Conversion;
with Ada.Numeric.Generic_Elementary_Functions;

with Interfaces;
use Interfaces;

<if(simu)>
--  Access to C compatible types when interacting with another language
with Interfaces.C.Strings;
use Interfaces.C.Strings;

<endif>

package body <name> is
    <if(dcl)>
    --  Local variables declared in textboxes
    <dcl; separator="\n">
    <endif>
    ---------------------------------------------------------------------------
    --  List of SDL states, and variable holding the current state
    type States is (<states; separator=", ">);
    state: States;
    <if(pdecl)>
    --  Declaration of inner procedures
    <pdecl; separator="\n">
    <endif>

    <if(simu)>
    --  External API to get/set the SDL state from a remote C application
    function get_state return chars_ptr is (New_String(States'Image(state)))
        with Export, Convention => C, Link_Name => "<name>_state";
    procedure set_state(new_state: chars_ptr);
    pragma export(C, set_state, "_set_state");
    ---------------------------------------------------------------------------
    <endif>
    <if(constants)>
    --  Constants holding substate identifier for the start transition
    <constants; separator="\n">
    ---------------------------------------------------------------------------
    <endif>
    --  Declaration of the procedure executing transitions
    procedure RunTransition(Id: Integer);

    <if(simu)>
    --  Implementation of the set_state procedure
    procedure set_state(new_state: chars_ptr) is
    begin
        state := States'Value(Value(new_state));
    end set_state;
    --  Implementation of the variable setters for external C access
    <vars: {each |
procedure dll_set_l_<each.name>(value: access <each.sort>) is
begin
    l_<each.name> := value.all;
end dll_set_l_<each.name>;
    }; separator="\n">
    ---------------------------------------------------------------------------
    <endif>
    <pcode; separator="\n">
    <arrs_inp; separator = "\n">
    <arrs_ri; separator = "\n">

    --  Process initialization: execute the START transition)
    begin
        RunTransition(0);
end <name>;
>>

/* Variable declaration (DCL var sort [:= def_expr]; */
dcl(var, def_expr, simu) ::= <<
l_<var.name> : aliased <var.sort><if(def_expr)> := <def_expr><endif>;
<if(simu)>
function l_<var.name>_size return Integer is (l_<var.name>'Size/8)
    with Export, Convention => C, Link_Name => "<var.name>_size";
function l_<var.name>_value return access <var.sort> is (l_<var.name>'access)
    with Export, Convention => C, Link_Name => "<var.name>_value";
procedure dll_set_l_<var.name>(value: access <var.sort>);
pragma Export(C, dll_set_l_<var.name>, "_set_<var.name>");
<endif>
>>


/* Code for a provided interface or timer timout signal */
input_signal(header, name, process, cases) ::= <<
--  Provided interface <name>
<header> is
    begin
       case state is
            <cases>
            when others =>
                null;
        end case;
end <name>;

>>

/* Case state to be used to select what transition to run
   When leaving a state, it may be necessary to call the exit procedure of
   inner states. The list of such procedures is in arrs_exitproc.
   There can also be parameters (only one in practice at the moment), which
   have to be assigned to a local variable: they are in arrs_param_assig
*/
case_state(name, arrs_exitproc, arrs_param_assig, transition) ::= <<
when <name> =>
    <arrs_param_assig; separator="\n">
    <arrs_exitproc: {each | p<safe_separator()><each><safe_separator()>exit;};separator="\n">
    <if(transition)>runTransition(<transition>);<else>null;<endif>
>>

/* Assign a parameter of an input signal to a local variable */
assign_param(local_var, param_name) ::= "l_<local_var> := <param_name>.all;"

/* Provided interface header, used in declaration and definition */
pi_signature(name, param_name, param_sort) ::= <<
procedure <name>
<if(param_sort)>
(<if(param_name)><param_name><else><name>_param<endif>: access <param_sort>)
<endif>
>>

/* Code for a (stateless) procedure */
procedure_definition(header, name, dcl, other_decl, start, labels) ::= <<
<header> is
    <if(dcl)>
    --  Procedure local variables declared in textboxes
    <dcl; separator="\n">
    <endif>
    <if(other_decl)>
    --  Other local declarations needed to support all SDL constructs
    <other_decl; separator="\n">
    <endif>
    begin
        <start>
        <if(!start)>
        null;  --  Empty procedure
        <endif>
        <labels>
end p<safe_separator()><name>;

>>


procedure_declaration(header, name, external) ::= <<
<header>;
<if(external)>
pragma import(C, <name>);
<endif>
>>


/* Header of a procedure */
procedure_signature(name, external, fpar) ::= <<
procedure <if(!external)>p<safe_separator()><endif><name>
<if(fpar)>
(<fpar: {each| l_<each.name>: <each.direction> <each.sort>}; separator="; ">)
<endif>
>>


/* Code for external RI */
required_interface(name, simu) ::= <<
<if(simu)>
procedure Register_<name>(Callback: <name>_T) is
begin
    <name> := Callback;
end Register_<name>;
<endif>
>>


/* Template for floating labels */
floating_label(name, traceability, transition) ::= <<
<traceability>
\<\<<name>\>\>
    <transition>
<if(!transition)>
    return;
<endif>
>>

/* Template for a label within a procedure, i.e connecting to a floating */
label(name) ::= "goto <name>;"

/* Constant declaration */
constant(var, val) ::= "<var> : constant := <val>;"

direction_in() ::= "in"
direction_out() ::= "in out"

comment(lines) ::= "--  <lines; separator="\n--  ">"

safe_separator() ::= "<\u00dc>"
